#!/usr/bin/env python3

# ===============================================================================
#                     CORE MERGER TRAJECTORY ANALYSIS SCRIPT
# ===============================================================================
# 
# This Python script analyzes and visualizes the trajectories of two compact objects
# (cores) from smoothed particle hydrodynamics (SPH) simulation data. The script is
# designed to work with output files from the StarSmasher SPH code.
#
# Pau Amaro Seoane, amaro@riseup.net
# 
# PHYSICAL PROBLEM 
# 
# The script addresses the physical scenario of binary star system evolution and 
# merger, specifically tracking:
# - The 3D trajectories of two stellar cores (particles of type 2 in SPH)
# - Their separation distance as a function of time
# - The merger event when cores come within their combined radii
# 
# Typical applications include:
# - Common envelope evolution
# - Binary star mergers
# - Stellar collisions
# - Compact object (WD/NS/BH) mergers
# 
#  SCRIPT FUNCTIONALITY 
# 
# The script performs the following key operations:
# 
# 1. FILE INPUT/OUTPUT:
#    - Reads SPH ascii files (out*.sph.ascii) created by SPLASH converter
#    - Can read/write a consolidated trajectory file (compact_objects_trajectory.ascii)
#    - Handles both regenerating data from SPH files or using existing trajectory files
# 
# 2. DATA PROCESSING:
#    - Extracts positions of type=2 particles (cores)
#    - Calculates 3D distances between cores at each timestep
#    - Normalizes distances and times if requested
#    - Converts between different unit systems
# 
# 3. VISUALIZATION:
#    - 2D trajectory plots (XY, XZ, YZ planes) with time-color coding
#    - Distance vs time plots with optional core radius indicator
#    - Multiple unit system support
#    - Logarithmic scale options
# 
# 4. USER INTERACTION:
#    - Interactive menu system for plot/unit selection
#    - Error checking and validation of user inputs
#    - Helpful conversion factor displays
# 
#  REQUIRED INPUT FILES 
# 
# The script requires one of the following input file sets:
# 
# 1. SPH ASCII FILES:
#    - Pattern: out*.sph.ascii
#    - Generated by running: 
#      `StSm_TrajectoryAscii.sh` or manually:
#      `splash to ascii -f starsmasher --convert=7,1,2,3,4,5,6,14 out*.sph`
#    - Contains particle data with columns: 
#      [id, x, y, z, vx, vy, vz, itype] + others
#    - Must contain particles with itype=2 (cores)
# 
# 2. TRAJECTORY FILE (optional):
#    - compact_objects_trajectory.ascii
#    - Created by this script when reading SPH files
#    - Format:
#      # Trajectory of compact objects with separation distance
#      # time x1 y1 z1 x2 y2 z2 distance
#      [8 columns of data]
# 
#  PHYSICAL UNIT SYSTEMS 
# 
# The script supports 4 unit systems with automatic conversions:
# 
# 1. NORMALIZED UNITS:
#    - Distances: R/R0 (initial separation)
#    - Time: T/Ttot (total simulation time)
# 
# 2. PHYSICAL UNITS (PARSEC):
#    - Distances: parsecs (pc)
#    - Mass: solar masses (Msun)
#    - Time: days
# 
# 3. CODE UNITS:
#    - Native simulation units:
#      - Length: 6.9599e10 cm (1 Rsun)
#      - Mass: 1.9891e33 g (1 Msun)
#      - Time: 1.8445e-02 days
# 
# 4. PHYSICAL UNITS (SOLAR RADII):
#    - Distances: solar radii (Rsun)
#    - Mass: solar masses (Msun)
#    - Time: days
# 
# Conversion factors are defined at the top of the script and can be adjusted.
# 
#  CORE ALGORITHM 
# 
# The main algorithm workflow:
# 
# 1. FILE READING:
#    - For each SPH ascii file:
#      a) Extract simulation time from header
#      b) Find all particles with itype=2
#      c) Store positions of first two type=2 particles (cores)
#    - If reading existing trajectory file, directly load all columns
# 
# 2. DISTANCE CALCULATION:
#    - For each timestep:
#      distance = sqrt((x2-x1)² + (y2-y1)² + (z2-z1)²)
#    - Store initial separation (d0) and total time (t_tot)
# 
# 3. UNIT CONVERSION:
#    - Apply selected unit system conversions to all quantities
#    - Handles both spatial and temporal unit conversions
# 
# 4. VISUALIZATION:
#    - For trajectory plots:
#      * Create fading colormap based on time
#      * Plot each segment with color corresponding to its time
#      * Different line styles for each core
#    - For distance-time plots:
#      * Optionally show core radius threshold
#      * Handle linear/logarithmic axis scaling
# 
#  KEY FUNCTIONS 
# 
# 1. read_sph_files():
#    - Main file parser that extracts core positions from SPH ascii files
#    - Handles file pattern matching and error checking
# 
# 2. calculate_distances():
#    - Computes 3D Euclidean distance between cores at each timestep
# 
# 3. plot_2d_trajectory():
#    - Creates time-colored 2D trajectory plots with fading effect
#    - Uses LinearSegmentedColormap for smooth color transitions
# 
# 4. plot_both_trajectories():
#    - Plots both core trajectories simultaneously with distinct styles
# 
# 5. plot_distance_vs_time():
#    - Creates distance vs time plots with multiple scale options
#    - Includes core radius indicator line when relevant
# 
# 6. create_fading_colormap():
#    - Generates custom colormaps that fade to transparent
#    - Used for time-based trajectory coloring
# 
#  EXECUTION FLOW 
# 
# 1. Initialize:
#    - Set physical constants and style parameters
#    - Display conversion factors
# 
# 2. User Interaction:
#    - Get unit system preference
#    - Get time unit preference
#    - Check for existing trajectory file
# 
# 3. Data Processing:
#    - Either read SPH files or existing trajectory
#    - Calculate distances if needed
#    - Write trajectory file if regenerating
# 
# 4. Visualization:
#    - Get plot type preference (trajectory or distance-time)
#    - Generate requested plot with selected units
#    - Apply all styling and labeling
# 
# 5. Output:
#    - Display interactive matplotlib figures
#    - Save trajectory data to ASCII file
# 
#  CUSTOMIZATION 
# 
# Key parameters that can be modified:
# 
# 1. PHYSICAL CONSTANTS:
#    - CODE_UNIT_MASS, CODE_UNIT_LENGTH, CODE_UNIT_TIME
#    - CORE_RADIUS_RSUN (default core radius)
# 
# 2. PLOT STYLING:
#    - GLOBAL_FONT_SIZE, GLOBAL_LINE_WIDTH, GLOBAL_TICK_SIZE
#    - Colormap colors in plot functions
# 
# 3. FILE HANDLING:
#    - Input file pattern (currently 'out*.sph.ascii')
#    - Output filename (currently 'compact_objects_trajectory.ascii')
# 
#  ERROR HANDLING 
# 
# The script includes several error checks:
# 
# 1. Input file validation:
#    - Checks for existence of SPH ascii files
#    - Verifies trajectory file format
# 
# 2. Data validation:
#    - Confirms at least two type=2 particles exist
#    - Checks for consistent array lengths
# 
# 3. User input validation:
#    - Validates all menu choices
#    - Checks numerical inputs for core radius
# 
# 4. Exception handling:
#    - Catches and reports runtime errors
#    - Provides meaningful error messages
# 
#  DEPENDENCIES 
# 
# Required Python packages:
# - numpy (for array operations)
# - matplotlib (for visualization)
# - glob (for file pattern matching)
# 
# The script uses standard Python libraries and requires no additional installation
# beyond a typical scientific Python environment.
# 
# ===============================================================================

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc
import glob
import sys
import os
from matplotlib.colors import LinearSegmentedColormap

# =============================================
# PHYSICAL UNIT CONVERSION FACTORS (from log0.sph)
# =============================================
CODE_UNIT_MASS = 1.9891e33    # g (1 Msun)
CODE_UNIT_LENGTH = 6.9599e10  # cm (1 Rsun)
CODE_UNIT_TIME = 1.8445e-02   # days
PC_PER_CM = 1/3.086e18        # Convert cm to parsecs
RSUN_PER_CM = 1/6.9599e10     # Convert cm to solar radii

# Core radius parameters
CORE_RADIUS_RSUN = 0.05       # Default core radius in solar radii
CORE_RADIUS_PC = CORE_RADIUS_RSUN * CODE_UNIT_LENGTH * RSUN_PER_CM * PC_PER_CM

# =============================================
# GLOBAL STYLE PARAMETERS
# =============================================
GLOBAL_FONT_SIZE = 35
GLOBAL_LINE_WIDTH = 3
GLOBAL_TICK_SIZE = 30

# LaTeX setup with global styles
rc('text', usetex=True)
rc('font', family='serif', size=GLOBAL_FONT_SIZE)
rc('axes', titlesize=GLOBAL_FONT_SIZE, labelsize=GLOBAL_FONT_SIZE)
rc('xtick', labelsize=GLOBAL_TICK_SIZE)
rc('ytick', labelsize=GLOBAL_TICK_SIZE)

def get_unit_preferences():
    """Get user preferences for unit systems"""
    print("\nAvailable unit systems:")
    print("1: Normalized units (R/R0, T/Ttot)")
    print("2: Physical units (parsecs, solar masses, days)")
    print("3: Code units (simulation native)")
    print("4: Physical units (solar radii, solar masses, days)")
    
    while True:
        choice = input("Select unit system [1/2/3/4]: ").strip()
        if choice in ['1', '2', '3', '4']:
            return int(choice)
        print("Invalid choice. Please enter 1, 2, 3, or 4")

def get_time_preferences(unit_choice):
    """Get user preferences for time units"""
    if unit_choice == 1:  # Normalized units already handle time
        return 'normalized'
    
    print("\nAvailable time units:")
    print("1: Code units")
    print("2: Days")
    if unit_choice == 1:
        print("3: Normalized (T/Ttot)")
    
    while True:
        choice = input("Select time units [1/2]: ").strip()
        if choice in ['1', '2']:
            return 'code' if choice == '1' else 'days'
        print("Invalid choice. Please enter 1 or 2")

def create_fading_colormap(base_color, n_segments=100):
    """Create a colormap that fades from base_color to transparent"""
    return LinearSegmentedColormap.from_list(
        'fading', 
        [(*base_color, 1.0), (*base_color, 0.1)],
        N=n_segments
    )

def read_sph_files(file_pattern):
    """Read all SPH files and extract positions of itype=2 particles"""
    files = sorted(glob.glob(file_pattern))
    if not files:
        print("\nERROR: No ASCII files found matching pattern 'out*.sph.ascii'")
        print("You can create these files by running:")
        print("  StSm_TrajectoryAscii.sh")
        print("which executes:")
        print("  `which splash` to ascii -f starsmasher --convert=7,1,2,3,4,5,6,14 out*.sph")
        sys.exit(1)

    particle1 = {'x': [], 'y': [], 'z': []}
    particle2 = {'x': [], 'y': [], 'z': []}
    times = []

    for fname in files:
        with open(fname, 'r') as f:
            # Get time from file
            time = 0.0
            for line in f:
                if line.startswith('# time:'):
                    time_line = next(f).strip()
                    if time_line.startswith('#'):
                        time_values = time_line[1:].strip().split()
                    else:
                        time_values = time_line.split()
                    if time_values:
                        try:
                            time = float(time_values[0])
                        except ValueError:
                            pass
                    break

            current_particles = {'x': [], 'y': [], 'z': []}
            for line in f:
                if not line.startswith('#') and line.strip():
                    parts = line.strip().split()
                    if len(parts) >= 8 and int(parts[-1]) == 2:
                        current_particles['x'].append(float(parts[1]))
                        current_particles['y'].append(float(parts[2]))
                        current_particles['z'].append(float(parts[3]))

            if len(current_particles['x']) >= 2:
                times.append(time)
                particle1['x'].append(current_particles['x'][0])
                particle1['y'].append(current_particles['y'][0])
                particle1['z'].append(current_particles['z'][0])
                particle2['x'].append(current_particles['x'][1])
                particle2['y'].append(current_particles['y'][1])
                particle2['z'].append(current_particles['z'][1])

    return (np.array(times),
            np.array(particle1['x']), np.array(particle1['y']), np.array(particle1['z']),
            np.array(particle2['x']), np.array(particle2['y']), np.array(particle2['z']))

def calculate_distances(x1, y1, z1, x2, y2, z2):
    """Calculate distances between corresponding points"""
    return np.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)

def write_trajectory_file(times, x1, y1, z1, x2, y2, z2, distances, filename):
    """Write trajectory data to file with distance column"""
    with open(filename, 'w') as f:
        f.write('# Trajectory of compact objects with separation distance\n')
        f.write('# time x1 y1 z1 x2 y2 z2 distance\n')
        for i in range(len(times)):
            f.write(f'{times[i]:.8E} {x1[i]:.8E} {y1[i]:.8E} {z1[i]:.8E} '
                    f'{x2[i]:.8E} {y2[i]:.8E} {z2[i]:.8E} '
                    f'{distances[i]:.8E}\n')

def read_trajectory_file(filename):
    """Read existing trajectory file with distance column"""
    times, x1, y1, z1, x2, y2, z2, distances = [], [], [], [], [], [], [], []
    with open(filename, 'r') as f:
        for line in f:
            if not line.startswith('#'):
                parts = line.strip().split()
                if len(parts) >= 8:
                    times.append(float(parts[0]))
                    x1.append(float(parts[1]))
                    y1.append(float(parts[2]))
                    z1.append(float(parts[3]))
                    x2.append(float(parts[4]))
                    y2.append(float(parts[5]))
                    z2.append(float(parts[6]))
                    distances.append(float(parts[7]))
    return (np.array(times),
            np.array(x1), np.array(y1), np.array(z1),
            np.array(x2), np.array(y2), np.array(z2),
            np.array(distances))

def plot_2d_trajectory(x, y, xlabel, ylabel, d0, times, color, linestyle, unit_choice, time_units):
    """Plot 2D trajectory with fading color"""
    fig, ax = plt.subplots(figsize=(12, 10))
    
    # Apply unit conversion
    if unit_choice == 2:  # Physical units (pc)
        x_plot = x * CODE_UNIT_LENGTH * PC_PER_CM
        y_plot = y * CODE_UNIT_LENGTH * PC_PER_CM
        d0_plot = d0 * CODE_UNIT_LENGTH * PC_PER_CM
    elif unit_choice == 4:  # Physical units (Rsun)
        x_plot = x * CODE_UNIT_LENGTH * RSUN_PER_CM
        y_plot = y * CODE_UNIT_LENGTH * RSUN_PER_CM
        d0_plot = d0 * CODE_UNIT_LENGTH * RSUN_PER_CM
    else:  # Normalized or code units
        x_plot = x
        y_plot = y
        d0_plot = d0

    cmap = create_fading_colormap(color)
    norm = plt.Normalize(times.min(), times.max())

    for i in range(len(x_plot)-1):
        ax.plot(x_plot[i:i+2]/d0_plot, y_plot[i:i+2]/d0_plot,
               linestyle=linestyle,
               color=cmap(norm(times[i])),
               linewidth=GLOBAL_LINE_WIDTH)

    ax.set_xlabel(xlabel, fontsize=GLOBAL_FONT_SIZE)
    ax.set_ylabel(ylabel, fontsize=GLOBAL_FONT_SIZE)
    ax.tick_params(axis='both', which='major', labelsize=GLOBAL_TICK_SIZE)
    plt.tight_layout()
    plt.show()

def plot_both_trajectories(x1, y1, x2, y2, xlabel, ylabel, d0, times, unit_choice, time_units):
    """Plot both trajectories with fading colors and different line styles"""
    fig, ax = plt.subplots(figsize=(12, 10))

    # Apply unit conversion
    if unit_choice == 2:  # Physical units (pc)
        x1_plot = x1 * CODE_UNIT_LENGTH * PC_PER_CM
        y1_plot = y1 * CODE_UNIT_LENGTH * PC_PER_CM
        x2_plot = x2 * CODE_UNIT_LENGTH * PC_PER_CM
        y2_plot = y2 * CODE_UNIT_LENGTH * PC_PER_CM
        d0_plot = d0 * CODE_UNIT_LENGTH * PC_PER_CM
    elif unit_choice == 4:  # Physical units (Rsun)
        x1_plot = x1 * CODE_UNIT_LENGTH * RSUN_PER_CM
        y1_plot = y1 * CODE_UNIT_LENGTH * RSUN_PER_CM
        x2_plot = x2 * CODE_UNIT_LENGTH * RSUN_PER_CM
        y2_plot = y2 * CODE_UNIT_LENGTH * RSUN_PER_CM
        d0_plot = d0 * CODE_UNIT_LENGTH * RSUN_PER_CM
    else:  # Normalized or code units
        x1_plot = x1
        y1_plot = y1
        x2_plot = x2
        y2_plot = y2
        d0_plot = d0

    cmap1 = create_fading_colormap((0.2, 0.4, 0.8))  # Blue-ish
    cmap2 = create_fading_colormap((0.8, 0.4, 0.2))  # Red-ish
    norm = plt.Normalize(times.min(), times.max())

    for i in range(len(x1_plot)-1):
        ax.plot(x1_plot[i:i+2]/d0_plot, y1_plot[i:i+2]/d0_plot,
               linestyle='-',
               color=cmap1(norm(times[i])),
               linewidth=GLOBAL_LINE_WIDTH,
               label='Core 1' if i == 0 else "")

    for i in range(len(x2_plot)-1):
        ax.plot(x2_plot[i:i+2]/d0_plot, y2_plot[i:i+2]/d0_plot,
               linestyle='--',
               color=cmap2(norm(times[i])),
               linewidth=GLOBAL_LINE_WIDTH,
               label='Core 2' if i == 0 else "")

    ax.set_xlabel(xlabel, fontsize=GLOBAL_FONT_SIZE)
    ax.set_ylabel(ylabel, fontsize=GLOBAL_FONT_SIZE)
    ax.legend(fontsize=GLOBAL_FONT_SIZE-4)
    ax.tick_params(axis='both', which='major', labelsize=GLOBAL_TICK_SIZE)
    plt.tight_layout()
    plt.show()

def plot_distance_vs_time(times, distances, d0, t_tot, unit_choice, time_units):
    """Plot distance between particles with user-selected options"""
    # Get core radii sum from user
    core_radius = None
    if unit_choice in [2, 4]:  # Only for physical units
        use_core_line = get_user_choice(
            "Do you want to plot a line for the sum of core radii? [y/n]: ", ['y', 'n'])
        if use_core_line == 'y':
            if unit_choice == 2:  # pc
                default_radius = 2 * CORE_RADIUS_PC
                prompt = f"Enter sum of core radii (pc) [default=2xRcore={default_radius:.2e}pc]: "
            else:  # Rsun
                default_radius = 2 * CORE_RADIUS_RSUN
                prompt = f"Enter sum of core radii (Rsun) [default=2xRcore={default_radius:.2f}]: "
            
            try:
                input_str = input(prompt)
                core_radius = float(input_str) if input_str else default_radius
            except ValueError:
                print(f"Invalid input. Using default value: {default_radius}")
                core_radius = default_radius

    # Handle time units
    if unit_choice == 1:  # Normalized units
        x = times / t_tot
        xlabel = r'$T/T_{\rm tot}$'
    else:
        if time_units == 'days':
            x = times * CODE_UNIT_TIME
            xlabel = 'Time (days)'
        else:  # code units
            x = times
            xlabel = 'Time (code units)'

    # Handle distance units
    if unit_choice == 1:  # Normalized units
        y = distances / d0
        ylabel = r'$R/d_0$'
    elif unit_choice == 2:  # Physical units (pc)
        y = distances * CODE_UNIT_LENGTH * PC_PER_CM
        ylabel = 'Distance (pc)'
        print(f"\nPhysical units conversion:")
        print(f"  1 code length = {CODE_UNIT_LENGTH*PC_PER_CM:.3e} pc")
        print(f"  1 code mass = {CODE_UNIT_MASS/1.9891e33:.3f} Msun")
        print(f"  1 code time = {CODE_UNIT_TIME:.3f} days")
    elif unit_choice == 4:  # Physical units (Rsun)
        y = distances * CODE_UNIT_LENGTH * RSUN_PER_CM
        ylabel = r'Distance ($R_\odot$)'
        print(f"\nPhysical units conversion:")
        print(f"  1 code length = {CODE_UNIT_LENGTH*RSUN_PER_CM:.3f} Rsun")
        print(f"  1 code mass = {CODE_UNIT_MASS/1.9891e33:.3f} Msun")
        print(f"  1 code time = {CODE_UNIT_TIME:.3f} days")
    else:  # Code units
        y = distances
        ylabel = 'Distance (code units)'

    log_choice = get_user_choice(
        "Log scale options:\n"
        "  (1) Linear x and y\n"
        "  (2) Log x\n"
        "  (3) Log y\n"
        "  (4) Log x and y\n"
        "Your choice [1/2/3/4]: ", ['1', '2', '3', '4'])

    fig, ax = plt.subplots(figsize=(12, 10))
    ax.plot(x, y, '-', color='black', linewidth=GLOBAL_LINE_WIDTH)
    
    # Plot core radius line if requested
    if core_radius is not None:
        if unit_choice == 2:  # pc
            label = r'$2 \times R_{\rm core} = %.2e\,{\rm pc}$' % core_radius
        else:  # Rsun
            label = r'$2 \times R_{\rm core} = %.2f\,R_\odot$' % core_radius
            
        ax.axhline(y=core_radius, color='gray', linestyle='--', 
                  alpha=0.5, linewidth=GLOBAL_LINE_WIDTH-1,
                  label=label)
        ax.legend(fontsize=GLOBAL_FONT_SIZE-4)

    ax.set_xlabel(xlabel, fontsize=GLOBAL_FONT_SIZE)
    ax.set_ylabel(ylabel, fontsize=GLOBAL_FONT_SIZE)

    if log_choice in ['2', '4']:
        ax.set_xscale('log')
    if log_choice in ['3', '4']:
        ax.set_yscale('log')

    ax.tick_params(axis='both', which='major', labelsize=GLOBAL_TICK_SIZE)
    plt.tight_layout()
    plt.show()

def get_user_choice(prompt, valid_options):
    """Get validated user input"""
    while True:
        choice = input(prompt).lower()
        if choice in valid_options:
            return choice
        print(f"Invalid option. Please choose from: {', '.join(valid_options)}")

def main():
    try:
        print("=== Core Merger Analysis ===")
        print(f"Using conversion factors from log0.sph:")
        print(f"  1 code length = {CODE_UNIT_LENGTH:.3e} cm")
        print(f"  1 code mass = {CODE_UNIT_MASS:.3e} g (1 Msun)")
        print(f"  1 code time = {CODE_UNIT_TIME:.3f} days")
        
        unit_choice = get_unit_preferences()
        time_units = 'normalized' if unit_choice == 1 else get_time_preferences(unit_choice)
        output_file = 'compact_objects_trajectory.ascii'

        if os.path.exists(output_file):
            print(f"\nFound existing trajectory file: {output_file}")
            choice = get_user_choice(
                "Do you want to:\n"
                "  (r)egenerate from SPH files\n"
                "  (p)lot from existing file\n"
                "  (q)uit\n"
                "Your choice [r/p/q]: ", ['r', 'p', 'q'])

            if choice == 'q':
                return
            elif choice == 'p':
                times, x1, y1, z1, x2, y2, z2, distances = read_trajectory_file(output_file)
                if len(times) == 0:
                    print("ERROR: No valid data in trajectory file")
                    return
            else:  # 'r'
                times, x1, y1, z1, x2, y2, z2 = read_sph_files('out*.sph.ascii')
                distances = calculate_distances(x1, y1, z1, x2, y2, z2)
                write_trajectory_file(times, x1, y1, z1, x2, y2, z2, distances, output_file)
                print(f"Trajectory data written to {output_file}")
        else:
            times, x1, y1, z1, x2, y2, z2 = read_sph_files('out*.sph.ascii')
            distances = calculate_distances(x1, y1, z1, x2, y2, z2)
            write_trajectory_file(times, x1, y1, z1, x2, y2, z2, distances, output_file)
            print(f"Trajectory data written to {output_file}")

        if len(times) == 0:
            print("ERROR: No valid trajectory data")
            return

        d0 = distances[0] if len(distances) > 0 else 1.0
        t_tot = times[-1] if len(times) > 0 else 1.0
        print(f"\nInitial separation: {d0:.3f} code units")
        print(f"Total time: {t_tot:.3f} code units ({t_tot*CODE_UNIT_TIME:.3f} days)")

        plot_choice = get_user_choice(
            "Select plot type:\n"
            "  (1) Particle trajectory\n"
            "  (2) Distance vs time\n"
            "Your choice [1/2]: ", ['1', '2'])

        if plot_choice == '1':
            particle_choice = get_user_choice(
                "Select which particle to plot (1/2/both) and plane (xy/xz/yz) [e.g., 'bothxy' or '2xy']: ",
                ['1xy', '1xz', '1yz', '2xy', '2xz', '2yz', 'bothxy', 'bothxz', 'bothyz'])

            particle = particle_choice.replace('xy', '').replace('xz', '').replace('yz', '')
            plane = particle_choice[-2:]

            if particle == 'both':
                if plane == 'xy':
                    plot_both_trajectories(x1, y1, x2, y2, r'$x/d_0$', r'$y/d_0$', d0, times, unit_choice, time_units)
                elif plane == 'xz':
                    plot_both_trajectories(x1, z1, x2, z2, r'$x/d_0$', r'$z/d_0$', d0, times, unit_choice, time_units)
                else:
                    plot_both_trajectories(y1, z1, y2, z2, r'$y/d_0$', r'$z/d_0$', d0, times, unit_choice, time_units)
            else:
                if particle == '1':
                    x, y, z = x1, y1, z1
                    color = (0.2, 0.4, 0.8)
                    linestyle = '-'
                else:
                    x, y, z = x2, y2, z2
                    color = (0.8, 0.4, 0.2)
                    linestyle = '--'

                if plane == 'xy':
                    plot_2d_trajectory(x, y, r'$x/d_0$', r'$y/d_0$', d0, times, color, linestyle, unit_choice, time_units)
                elif plane == 'xz':
                    plot_2d_trajectory(x, z, r'$x/d_0$', r'$z/d_0$', d0, times, color, linestyle, unit_choice, time_units)
                else:
                    plot_2d_trajectory(y, z, r'$y/d_0$', r'$z/d_0$', d0, times, color, linestyle, unit_choice, time_units)
        else:
            plot_distance_vs_time(times, distances, d0, t_tot, unit_choice, time_units)

    except Exception as e:
        print(f"ERROR: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
